public class Solution {
    Node[] nodes = null;

    public int MinMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.Length;
        nodes = new Node[n];

        // Initialize Union-Find
        for (int i = 0; i < n; i++) {
            nodes[i] = new Node(i);
        }

        // Perform Union for connected nodes
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1) {
                    Union(i, j);
                }
            }
        }

        // Sort initial array to prioritize smaller indices
        Array.Sort(initial);

        // Map each component's root to its size
        Dictionary<int, int> componentSizes = new Dictionary<int, int>();
        for (int i = 0; i < n; i++) {
            int root = Find(i);
            if (!componentSizes.ContainsKey(root)) {
                componentSizes[root] = 0;
            }
            componentSizes[root]++;
        }

        // Count malware nodes in each component
        Dictionary<int, int> malwareCount = new Dictionary<int, int>();
        foreach (int node in initial) {
            int root = Find(node);
            if (!malwareCount.ContainsKey(root)) {
                malwareCount[root] = 0;
            }
            malwareCount[root]++;
        }

        // Evaluate the best node to remove
        int bestNode = -1;
        int maxSaved = -1;

        foreach (int node in initial) {
            int root = Find(node);
            // Only consider nodes that isolate a component
            if (malwareCount[root] == 1) {
                int saved = componentSizes[root]; // Entire component can be saved
                if (saved > maxSaved || (saved == maxSaved && node < bestNode)) {
                    maxSaved = saved;
                    bestNode = node;
                }
            }
        }

        // If no valid node is found, return the smallest index in initial
        return bestNode == -1 ? initial[0] : bestNode;
    }

    private int Find(int n) {
        if (nodes[n].parent != n) {
            nodes[n].parent = Find(nodes[n].parent); // Path compression
        }
        return nodes[n].parent;
    }

    private bool Union(int x, int y){
        int rootX = Find(x);
        int rootY = Find(y);

        if(rootX == rootY){
            return true;
        }
        
        if(nodes[rootX].rank > nodes[rootY].rank){
            nodes[rootY].parent = rootX;
        }
        else if(nodes[rootX].rank < nodes[rootY].rank){
            nodes[rootX].parent = rootY;
        }
        else{
            nodes[rootX].parent = rootY;
            nodes[rootY].rank++;
        }

        return false;
    }  

    public class Node {
        public int parent;
        public int rank;

        public Node(int parent) {
            this.parent = parent;
            this.rank = 0;
        }
    }
}
